GFX_Char_Mai_Idle0: INCBIN "data/gfx/char/mai_idle0.bin"
GFX_Char_Mai_Idle1: INCBIN "data/gfx/char/mai_idle1.bin"
GFX_Char_Mai_Idle3: INCBIN "data/gfx/char/mai_idle3.bin"
GFX_Char_Mai_WalkF1: INCBIN "data/gfx/char/mai_walkf1.bin"
GFX_Char_Mai_WalkF2: INCBIN "data/gfx/char/mai_walkf2.bin"
GFX_Char_Mai_Crouch0: INCBIN "data/gfx/char/mai_crouch0.bin"
GFX_Char_Mai_CrouchWalkF1: INCBIN "data/gfx/char/mai_crouchwalkf1.bin"
GFX_Char_Mai_CrouchWalkF2: INCBIN "data/gfx/char/mai_crouchwalkf2.bin"
GFX_Char_Mai_JumpN1: INCBIN "data/gfx/char/mai_jumpn1.bin"
GFX_Char_Mai_JumpN2: INCBIN "data/gfx/char/mai_jumpn2.bin"
GFX_Char_Mai_BlockG0_A: INCBIN "data/gfx/char/mai_blockg0_a.bin"
GFX_Char_Mai_BlockG0_B: INCBIN "data/gfx/char/mai_blockg0_b.bin"
GFX_Char_Mai_BlockC0_A: INCBIN "data/gfx/char/mai_blockc0_a.bin"
GFX_Char_Mai_BlockC0_B: INCBIN "data/gfx/char/mai_blockc0_b.bin"
GFX_Char_Mai_Hit0Mid0_A: INCBIN "data/gfx/char/mai_hit0mid0_a.bin"
GFX_Char_Mai_HopB0_A: INCBIN "data/gfx/char/mai_hopb0_a.bin"
GFX_Char_Mai_HitLow0_A: INCBIN "data/gfx/char/mai_hitlow0_a.bin"
GFX_Char_Mai_LaunchUB2: INCBIN "data/gfx/char/mai_launchub2.bin"
GFX_Char_Mai_LaunchUB1: INCBIN "data/gfx/char/mai_launchub1.bin"
GFX_Char_Mai_PunchLN0_A: INCBIN "data/gfx/char/mai_punchln0_a.bin"
GFX_Char_Mai_PunchLN0_B: INCBIN "data/gfx/char/mai_punchln0_b.bin"
GFX_Char_Mai_PunchLN1_A: INCBIN "data/gfx/char/mai_punchln1_a.bin"
GFX_Char_Mai_PunchLM0_A: INCBIN "data/gfx/char/mai_punchlm0_a.bin"
GFX_Char_Mai_PunchLM1_A: INCBIN "data/gfx/char/mai_punchlm1_a.bin"
GFX_Char_Mai_PunchLM1_B: INCBIN "data/gfx/char/mai_punchlm1_b.bin"
GFX_Char_Mai_PunchHM1_A: INCBIN "data/gfx/char/mai_punchhm1_a.bin"
GFX_Char_Mai_KickLN0: INCBIN "data/gfx/char/mai_kickln0.bin"
GFX_Char_Mai_KickLN1_A: INCBIN "data/gfx/char/mai_kickln1_a.bin"
GFX_Char_Mai_KickLN1_B: INCBIN "data/gfx/char/mai_kickln1_b.bin"
GFX_Char_Mai_KickLM1_A: INCBIN "data/gfx/char/mai_kicklm1_a.bin"
GFX_Char_Mai_PunchCL1_A: INCBIN "data/gfx/char/mai_punchcl1_a.bin"
GFX_Char_Mai_PunchCL1_B: INCBIN "data/gfx/char/mai_punchcl1_b.bin"
GFX_Char_Mai_PunchCH1: INCBIN "data/gfx/char/mai_punchch1.bin"
GFX_Char_Mai_KickCL1: INCBIN "data/gfx/char/mai_kickcl1.bin"
GFX_Char_Mai_KickCH1: INCBIN "data/gfx/char/mai_kickch1.bin"
GFX_Char_Mai_PunchALI0: INCBIN "data/gfx/char/mai_punchali0.bin"
GFX_Char_Mai_KickAHI0: INCBIN "data/gfx/char/mai_kickahi0.bin"
GFX_Char_Mai_Dodge0_A: INCBIN "data/gfx/char/mai_dodge0_a.bin"
GFX_Char_Mai_DodgeCounter1: INCBIN "data/gfx/char/mai_dodgecounter1.bin"
GFX_Char_Mai_ThrowG1_A: INCBIN "data/gfx/char/mai_throwg1_a.bin"
GFX_Char_Mai_HishoRyuEnJin2_B: INCBIN "data/gfx/char/mai_hishoryuenjin2_b.bin"
GFX_Char_Mai_ChargeMeter1_A: INCBIN "data/gfx/char/mai_chargemeter1_a.bin"
GFX_Char_Mai_AttackA0: INCBIN "data/gfx/char/mai_attacka0.bin"
GFX_Char_Mai_Strike1: INCBIN "data/gfx/char/mai_strike1.bin"
GFX_Char_Mai_Taunt0: INCBIN "data/gfx/char/mai_taunt0.bin"
GFX_Char_Mai_Taunt1: INCBIN "data/gfx/char/mai_taunt1.bin"
GFX_Char_Mai_Win2: INCBIN "data/gfx/char/mai_win2.bin"
GFX_Char_Mai_Win3_A: INCBIN "data/gfx/char/mai_win3_a.bin"
GFX_Char_Mai_Win3_B: INCBIN "data/gfx/char/mai_win3_b.bin"
GFX_Char_Mai_Win4_A: INCBIN "data/gfx/char/mai_win4_a.bin"
GFX_Char_Mai_Unused_KaChoSen1XFlip: INCBIN "data/gfx/char/mai_unused_kachosen1xflip.bin"
GFX_Char_Mai_KaChoSen3_A: INCBIN "data/gfx/char/mai_kachosen3_a.bin"
GFX_Char_Mai_HissatsuShinobibachi0: INCBIN "data/gfx/char/mai_hissatsushinobibachi0.bin"
GFX_Char_Mai_HissatsuShinobibachi1: INCBIN "data/gfx/char/mai_hissatsushinobibachi1.bin"
GFX_Char_Mai_HissatsuShinobibachi3: INCBIN "data/gfx/char/mai_hissatsushinobibachi3.bin"
GFX_Char_Mai_Win0: INCBIN "data/gfx/char/mai_win0.bin"
GFX_Char_Mai_RyuEnBu2_A: INCBIN "data/gfx/char/mai_ryuenbu2_a.bin"
GFX_Char_Mai_RyuEnBu3_A: INCBIN "data/gfx/char/mai_ryuenbu3_a.bin"
GFX_Char_Mai_RyuEnBu3_B: INCBIN "data/gfx/char/mai_ryuenbu3_b.bin"
GFX_Char_Mai_RyuEnBu4_A: INCBIN "data/gfx/char/mai_ryuenbu4_a.bin"
GFX_Char_Mai_HishoRyuEnJin2_A: INCBIN "data/gfx/char/mai_hishoryuenjin2_a.bin"
GFX_Char_Mai_HishoRyuEnJin3_A: INCBIN "data/gfx/char/mai_hishoryuenjin3_a.bin"
GFX_Char_Mai_KuuchuuMusasabi1: INCBIN "data/gfx/char/mai_kuuchuumusasabi1.bin"
GFX_Char_Mai_ChoHissatsuShinobibachi3: INCBIN "data/gfx/char/mai_chohissatsushinobibachi3.bin"
GFX_Char_Mai_ChoHissatsuShinobibachi4: INCBIN "data/gfx/char/mai_chohissatsushinobibachi4.bin"
GFX_Char_Mai_PunchAHD0: INCBIN "data/gfx/char/mai_punchahd0.bin"

; =============== MoveC_Nakoruru_RoundStart ===============
; Move code for Nakoruru's Intro (MOVE_SHARED_INTRO).
; Nakoruru uses her own intro code because it has to spawn the bird.
MoveC_Nakoruru_RoundStart:

	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	
	; At the end of each frame...
	mMvC_ValFrameEnd .anim
		; Check if we can end the move when the target ID is reached
		mMvC_StartChkFrameInt	; A = Frame ID
			;--
			; (reverse of mMvC_ChkTarget)
			ld   hl, iPlInfo_OBJLstPtrTblOffsetMoveEnd
			add  hl, bc			; HL = Ptr to end target
			cp   a, [hl]		; Reached the last frame ID?
			jr   nz, .anim		; If not, skip
			;--
			
			; Otherwise, spawn the bird and end the move
			call Play_SpawnBird
			call Play_Pl_EndMove
			jr   .ret
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Nakoruru_ThrowG ===============
; Move code for Nakoruru's ground throw. (MOVE_SHARED_THROW_G).
MoveC_Nakoruru_ThrowG:
	mMvC_ValLoaded .ret
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $00, .setDamage
		mMvC_ChkFrame $01, .waitBackHop
	jp   .anim ; We never get here
; --------------- frame #0 ---------------
; Deal damage at the end of the frame.
.setDamage:
	mMvC_ValFrameEnd .anim
		mMvC_SetDamageNext $06, HITTYPE_LAUNCH_HIGH_UB, PF3_HEAVYHIT
		jp   .anim
; --------------- frame #1 ---------------
; Backhop away at the end of the frame.
.waitBackHop:
	mMvC_ValFrameEnd .anim
		ld   a, MOVE_SHARED_LAUNCH_UB_REC
		call Pl_SetMove_StopSpeed
		mMvC_SetSpeedH -$0300 ; 3px/frame back
		mMvC_SetSpeedV -$0500 ; 5px/frame up
		xor  a ; End throw sequence
		ld   [wPlayPlThrowActId], a
		jp   .ret
; --------------- common ---------------
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret  
	
; =============== MoveInputReader_Nakoruru ===============
; Special move input checker for THE BEST ONE.
; IN
; - BC: Ptr to wPlInfo
; - DE: Ptr to respective wOBJInfo
; OUT
; - C flag: If set, a move was started
MoveInputReader_Nakoruru:
	mMvIn_Validate Nakoruru, 1
	
.chkAir:
	;             SELECT + B                           SELECT + A
	mMvIn_ChkEasy MoveInit_Nakoruru_ElerushKamuiRimse, MoveInit_Nakoruru_YatoroPokku
	mMvIn_ChkGA Nakoruru, .chkAirPunch, 0, CHKGA_PUNCH
	
.chkAirPunch:
	mMvIn_ValSuper .chkAirPunchNoSuper
	; FDBFDB+P -> Elerush Kamui Rimse (Super Cape Swing)
	mMvIn_ChkDir MoveInput_FDBFDB, MoveInit_Nakoruru_ElerushKamuiRimse
.chkAirPunchNoSuper:
	; DB+P -> Yatoro Pokku (Spin)
	mMvIn_ChkDir MoveInput_DB, MoveInit_Nakoruru_YatoroPokku
	; DF+P -> Kamui Mutsube (Downwards Dash)
	mMvIn_ChkDir MoveInput_DF, MoveInit_Nakoruru_KamuiMutsube
	; End
	jp   MoveInputReader_Nakoruru_NoMove
	
.chkGround:
	;             SELECT + B                           SELECT + A
	mMvIn_ChkEasy MoveInit_Nakoruru_ElerushKamuiRimse, MoveInit_Nakoruru_AmubeYatoro
	mMvIn_ChkGA Nakoruru, .chkPunch, .chkKick, CHKGA_KICK|CHKGA_PUNCH
	
.chkPunch:
	mMvIn_ValSuper .chkPunchNoSuper
	; FDBFDB+P -> Elerush Kamui Rimse (Super Cape Swing)
	mMvIn_ChkDir MoveInput_FDBFDB, MoveInit_Nakoruru_ElerushKamuiRimse
.chkPunchNoSuper:

; With less strict inputs, the Cape Swing overlaps the Bird Throw, which is annoying.
; The English version also switches them around.
IF VER_EN || GOOD_INPUTS
	; FDB+P -> Amube Yatoro (Bird Throw)
	mMvIn_ChkDir MoveInput_FDB, MoveInit_Nakoruru_AmubeYatoro
	; BDB+P -> Kamui Rimse (Cape Swing)
	mMvIn_ChkDir MoveInput_BDB, MoveInit_Nakoruru_KamuiRimse
ELSE
	; BDB+P -> Kamui Rimse (Cape Swing)
	mMvIn_ChkDir MoveInput_BDB, MoveInit_Nakoruru_KamuiRimse
	; FDB+P -> Amube Yatoro (Bird Throw)
	mMvIn_ChkDir MoveInput_FDB, MoveInit_Nakoruru_AmubeYatoro
ENDC
	; BD+P -> Annu Mutsube (Horizontal Dash)
	mMvIn_ChkDir MoveInput_BD, MoveInit_Nakoruru_AnnuMutsube
	; DF+P -> Lela Mutsube (Upwards Dash)
	mMvIn_ChkDir MoveInput_DF, MoveInit_Nakoruru_LelaMutsube
	; End
	jp   MoveInputReader_Nakoruru_NoMove
.chkKick:
	; DB+K -> Mamahaha Flight (Timer Scam)
	mMvIn_ChkDir MoveInput_DB, MoveInit_Nakoruru_MamahahaFlight
	; End
	jp   MoveInputReader_Nakoruru_NoMove
	
; =============== MoveInit_Nakoruru_AmubeYatoro ===============
MoveInit_Nakoruru_AmubeYatoro:
	mMvIn_ValProjActive MoveInputReader_Nakoruru_NoMove
	call Play_Pl_ClearJoyDirBuffer
	mMvIn_GetLHP MOVE_NAKORURU_AMUBE_YATORO_L, MOVE_NAKORURU_AMUBE_YATORO_H
	call MoveInputS_SetSpecMove_StopSpeed
	call Play_Proj_CopyMoveDamageFromPl
	jp   MoveInputReader_Nakoruru_MoveSet
	
; =============== MoveInit_Nakoruru_AnnuMutsube ===============
MoveInit_Nakoruru_AnnuMutsube:
	call Play_Pl_ClearJoyDirBuffer
	mMvIn_GetLHP MOVE_NAKORURU_ANNU_MUTSUBE_L, MOVE_NAKORURU_ANNU_MUTSUBE_H
	call MoveInputS_SetSpecMove_StopSpeed
	ld   hl, iPlInfo_Flags1
	add  hl, bc
	set  PF1B_INVULN, [hl]
	jp   MoveInputReader_Nakoruru_MoveSet
	
; =============== MoveInit_Nakoruru_KamuiRimse ===============
MoveInit_Nakoruru_KamuiRimse:
	call Play_Pl_ClearJoyDirBuffer
	mMvIn_GetLHP MOVE_NAKORURU_KAMUI_RIMSE_L, MOVE_NAKORURU_KAMUI_RIMSE_H
	call MoveInputS_SetSpecMove_StopSpeed
	ld   hl, iPlInfo_Flags0
	add  hl, bc
	set  PF0B_PROJREFLECT, [hl]
	jp   MoveInputReader_Nakoruru_MoveSet
	
; =============== MoveInit_Nakoruru_LelaMutsube ===============
MoveInit_Nakoruru_LelaMutsube:
	call Play_Pl_ClearJoyDirBuffer
	mMvIn_GetLHP MOVE_NAKORURU_LELA_MUTSUBE_L, MOVE_NAKORURU_LELA_MUTSUBE_H
	call MoveInputS_SetSpecMove_StopSpeed
	ld   hl, iPlInfo_Flags1
	add  hl, bc
	set  PF1B_INVULN, [hl]
	jp   MoveInputReader_Nakoruru_MoveSet
	
; =============== MoveInit_Nakoruru_MamahahaFlight ===============
MoveInit_Nakoruru_MamahahaFlight:
	mMvIn_ValProjActive MoveInputReader_Nakoruru_NoMove
	call Play_Pl_ClearJoyDirBuffer
	mMvIn_GetLHK MOVE_NAKORURU_MAMAHAHA_FLIGHT_L, MOVE_NAKORURU_MAMAHAHA_FLIGHT_H
	call MoveInputS_SetSpecMove_StopSpeed
	jp   MoveInputReader_Nakoruru_MoveSet
	
; =============== MoveInit_Nakoruru_YatoroPokku ===============
MoveInit_Nakoruru_YatoroPokku:
	call Play_Pl_ClearJoyDirBuffer
	mMvIn_GetLHP MOVE_NAKORURU_YATORO_POKKU_L, MOVE_NAKORURU_YATORO_POKKU_H
	call MoveInputS_SetSpecMove_StopSpeed
	jp   MoveInputReader_Nakoruru_MoveSet
	
; =============== MoveInit_Nakoruru_KamuiMutsube ===============
MoveInit_Nakoruru_KamuiMutsube:
	call Play_Pl_ClearJoyDirBuffer
	mMvIn_GetLHP MOVE_NAKORURU_KAMUI_MUTSUBE_L, MOVE_NAKORURU_KAMUI_MUTSUBE_H
	call MoveInputS_SetSpecMove_StopSpeed
	jp   MoveInputReader_Nakoruru_MoveSet
	
; =============== MoveInit_Nakoruru_ElerushKamuiRimse ===============
MoveInit_Nakoruru_ElerushKamuiRimse:
	call Play_Pl_ClearJoyDirBuffer
	ld   a, MOVE_NAKORURU_ELERUSH_KAMUI_RIMSE_S
	call MoveInputS_SetSpecMove_StopSpeed
	call Play_Proj_CopyMoveDamageFromPl
	ld   hl, iPlInfo_Flags1
	add  hl, bc
	set  PF1B_INVULN, [hl]
	jp   MoveInputReader_Nakoruru_MoveSet
	
; =============== MoveInputReader_Nakoruru_MoveSet ===============
MoveInputReader_Nakoruru_MoveSet:
	scf  
	ret  
; =============== MoveInputReader_Nakoruru_NoMove ===============
MoveInputReader_Nakoruru_NoMove:
	or   a
	ret
	
; =============== MoveC_Nakoruru_AmubeYatoro ===============
; Move code for Nakoruru's Amube Yatoro (Bird Throw) (MOVE_NAKORURU_AMUBE_YATORO_L, MOVE_NAKORURU_AMUBE_YATORO_H).
; See also: MoveC_Kyo_YamiBarai
MoveC_Nakoruru_AmubeYatoro:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $02, .setDelay
		mMvC_ChkFrame $03, .obj3
	jp   .anim
	
; --------------- frame #2 ---------------	
.setDelay:
	mMvC_ValFrameEnd .anim
		
		;
		; The heavy version keeps Nakoruru in the "throw" frame for longer.
		;
		ld   hl, iPlInfo_MoveId
		add  hl, bc
		ld   a, [hl]						; A = Move ID
		ld   hl, iOBJInfo_FrameTotal
		add  hl, de							; Seek to anim speed
		cp   MOVE_NAKORURU_AMUBE_YATORO_H	; Doing the heavy version?
		jp   z, .heavy						; If so, jump
	.light:
		ld   [hl], $08						; iOBJInfo_FrameTotal = $08
		jp   .anim
	.heavy:
		ld   [hl], $10						; iOBJInfo_FrameTotal = $10
		jp   .anim
; --------------- frame #3 ---------------	
.obj3:
	; Spawn the projectile at the start.
	mMvC_ValFrameStartFast .chkEnd
		call ProjInit_Nakoruru_Bird
.chkEnd:
	mMvC_ValFrameEnd .anim
		call Play_Pl_EndMove
		jp   .ret
; --------------- common ---------------
.anim:
	jp   OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Nakoruru_AnnuMutsube ===============
; Move code for Nakoruru's Annu Mutsube (Horizontal Dash) (MOVE_NAKORURU_ANNU_MUTSUBE_L, MOVE_NAKORURU_ANNU_MUTSUBE_H).
MoveC_Nakoruru_AnnuMutsube:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $00, .obj0
		mMvC_ChkFrame $01, .obj1
		mMvC_ChkFrame $02, .setDamage
		mMvC_ChkFrame $03, .setDamage
		mMvC_ChkFrame $04, .setDamage
		mMvC_ChkFrame $05, .obj5
		mMvC_ChkFrame $06, .chkEnd
	jp   .moveH ; We never get here
; --------------- frame #0 ---------------
; Startup
.obj0:
	mMvC_ValFrameEnd .anim
		; Flash Nakoruru as fast as possible while dashing
		mMvC_SetAnimSpeed ANIMSPEED_INSTANT
		mMvC_PlaySound SFX_SPECIAL
		jp   .anim
; --------------- frame #1 ---------------
; Dash setup & exec.
.obj1:
	;
	; This move handles gravi
	;
	mMvC_ValFrameStartFast .obj1_cont
		;--
		; Remove invuln
		ld   hl, iPlInfo_Flags1
		add  hl, bc
		res  PF1B_INVULN, [hl]
		;--
		
		; Set horizontal movement speed.
		; This speed is constant during the dash.
		mMvC_ChkMove MOVE_NAKORURU_ANNU_MUTSUBE_H, .obj1_setDashH
	.obj1_setDashL: ; Light
		mMvC_SetSpeedH +$0300
		jp   .obj1_cont
	.obj1_setDashH: ; Heavy
		mMvC_ChkMaxPow .obj1_setDashE
		mMvC_SetSpeedH +$0400
		jp   .obj1_cont
	.obj1_setDashE: ; Max Power Heavy
		mMvC_SetSpeedH +$0600
.obj1_cont:
	jp   .moveH
; --------------- frames #2-4 ---------------
; Damage frames during the dash.
.setDamage:
	mMvC_ValFrameEnd .moveH
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_HEAVYHIT|PF3_HALFSPEED|PF3_SUPERALT
		jp   .moveH
; --------------- frame #5 ---------------
.obj5:
	; Set manual control at the end, in preparation for the friction check
	mMvC_ValFrameEnd .moveH
		mMvC_SetAnimSpeed ANIMSPEED_NONE
		jp   .moveH
; --------------- common horizontal movement / frames #1-5 ---------------
.moveH:
	; Continue moving at the same set speed.
	call OBJLstS_ApplyXSpeed
	jp   .anim
; --------------- frame #6 ---------------
.chkEnd:
	; Slow down at 0.25px/frame.
	; When we full stop moving, end the move.
	mMvC_ChkFrictionH $0040, .anim
		call Play_Pl_EndMove
		jp   .ret
; --------------- common ---------------
.anim:
	call OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Nakoruru_LelaMutsube ===============
; Move code for Nakoruru's Lela Mutsube (Upwards Dash) (MOVE_NAKORURU_LELA_MUTSUBE_L, MOVE_NAKORURU_LELA_MUTSUBE_H).
MoveC_Nakoruru_LelaMutsube:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $00, .obj0
		mMvC_ChkFrame $01, .obj1
		mMvC_ChkFrame $02, .setDamage
		mMvC_ChkFrame $03, .setDamage
		mMvC_ChkFrame $04, .setDamage
		mMvC_ChkFrame $05, .setDamage
		mMvC_ChkFrame $06, .setDamage
		mMvC_ChkFrame $07, .doGravityU
		mMvC_ChkFrame $0B, .objB
		mMvC_ChkFrame $0C, .chkEnd
; --------------- frames #8-A ---------------
	jp   .doGravity
; --------------- frame #0 ---------------
; Startup
.obj0:
	mMvC_ValFrameEnd .anim
		; Flash Nakoruru as fast as possible while dashing
		mMvC_SetAnimSpeed ANIMSPEED_INSTANT
		mMvC_PlaySound SFX_SPECIAL
		jp   .anim
; --------------- frame #1 ---------------
; Dash setup & exec.
.obj1:
	;
	; This move handles gravi
	;
	mMvC_ValFrameStartFast .obj1_cont
		;--
		; Remove invuln
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		set  PF0B_AIR, [hl]
		inc  hl
		res  PF1B_INVULN, [hl]
		;--
		
		; Set horizontal movement speed.
		; This speed is constant during the dash, which also has the effect that
		; it is only temporarily affected by the opponent's collision box.
		mMvC_ChkMove MOVE_NAKORURU_LELA_MUTSUBE_H, .obj1_setDashH
	.obj1_setDashL: ; Light
		mMvC_SetSpeedH +$0100
		jp   .obj1_cont
	.obj1_setDashH: ; Heavy
		mMvC_ChkMaxPow .obj1_setDashE
		mMvC_SetSpeedH +$0300
		jp   .obj1_cont
	.obj1_setDashE: ; Max Power Heavy
		mMvC_SetSpeedH +$0600
.obj1_cont:
	jp   .doGravityU
; --------------- frames #2-6 ---------------
; Damage frames during the dash.
; While this happens the reverse gravity is being applied, making Nakoruru progressively speed up.
.setDamage:
	mMvC_ValFrameEnd .doGravityU
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_HALFSPEED|PF3_SUPERALT
		jp   .doGravityU
; --------------- common upwards gravity / frames #1-7 ---------------
; Applies negative gravity, which causes the player's upwards speed to increase every frame.
; Because the horizontal speed is left untouched, eventually the vertical speed will overtake it.
; The result is the player moving in a curved arc, with different slants depending on how fast
; the player was moving horizontally.
.doGravityU:
	mMvC_DoGravityHV -$0028 ; $00.28px/frame up
	jp   .anim
; --------------- frame #B ---------------
; Falling, loop check.
.objB:
	; If we didn't touch the ground by the end of the frame, loop back to #8.
	; That's the first frame that applies normal gravity, used for downwards movement.
	mMvC_ValFrameEnd .doGravity
		mMvC_SetFrameOnEnd $08
; --------------- common downwards gravity / frames #8-B ---------------
; Applies positive gravity, causing the player to move down.
; This generally starts to happen when the player is off-screen above.
.doGravity:
	; When landing on the ground, switch to #C and stay in recovery for 10 frames.
	; This is easily punishable, and that's without accounting for being hit while falling down.
	mMvC_ChkGravityHV $0060, .anim
		;--
		; Allow special cancel
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		res  PF0B_AIR, [hl]
		inc  hl
		res  PF1B_NOSPECSTART, [hl]
		;--
		mMvC_SetLandFrame $0C, $0A
		jp   .ret
; --------------- frame #C ---------------
; Recovery.
.chkEnd:
	mMvC_ValFrameEnd .anim
		call Play_Pl_EndMove
		jr   .ret
; --------------- common ---------------
.anim:
	call OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Nakoruru_KamuiRimse ===============
; Move code for Nakoruru's Kamui Rimse (Cape Swing) (MOVE_NAKORURU_KAMUI_RIMSE_L, MOVE_NAKORURU_KAMUI_RIMSE_H).
MoveC_Nakoruru_KamuiRimse:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $00, .obj0
		mMvC_ChkFrame $01, .obj1
		mMvC_ChkFrame $02, .obj2
		mMvC_ChkFrame $03, .obj3
		mMvC_ChkFrame $04, .obj4
		mMvC_ChkFrame $05, .moveH
		mMvC_ChkFrame $06, .chkEnd
; --------------- frame #0 ---------------
.obj0:
	; Startup
	mMvC_ValFrameEnd .anim
		mMvC_SetAnimSpeed $01
		mMvC_PlaySound SCT_MOVEJUMP_A
		jp   .anim
; --------------- frame #1 ---------------
.obj1:
	; Set the initial movement speed the first time we get here
	mMvC_ValFrameStartFast .obj1_cont
		mMvC_ChkMove MOVE_NAKORURU_KAMUI_RIMSE_H, .obj1_setSpeedH
	.obj1_setSpeedL: ; Light
		mMvC_SetSpeedH +$0040
		jp   .obj1_cont
	.obj1_setSpeedH: ; Heavy
		mMvC_ChkMaxPow .obj1_setSpeedE
		mMvC_SetSpeedH +$0070
		jp   .obj1_cont
	.obj1_setSpeedE: ; Max Power Heavy
		mMvC_SetSpeedH +$0080
.obj1_cont:
	; Deal the first hit when the frame ends
	mMvC_ValFrameEnd .moveH
		mMvC_SetDamageNext $04, HITTYPE_HIT_MID0, $00
		jp   .moveH
; --------------- frame #2 ---------------
.obj2:
	; Deal the second hit at the end of the frame
	mMvC_ValFrameEnd .moveH
		mMvC_ChkMove MOVE_NAKORURU_KAMUI_RIMSE_H, .obj2_setDamageH
		
		; The light version of the move knocks down now.
		; This is because it ends early at the end of the next frame.
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_HEAVYHIT
		
		; For that same reason, adjust the animation speed for the recovery frame.
		; mMvC_SetAnimSpeed: $02
		ld   hl, iOBJInfo_FrameTotal
		add  hl, de
		ld   [hl], $02
		
		jp   .moveH
	.obj2_setDamageH:
		; The hard version is just another middle hit
		mMvC_SetDamageNext $04, HITTYPE_HIT_MID1, $00
		jp   .moveH
		
; --------------- frame #3 ---------------
.obj3:
	; At the end of the frame, if doing the light version, end the move.
	mMvC_ValFrameEnd .moveH
		mMvC_ChkMove MOVE_NAKORURU_KAMUI_RIMSE_H, .obj3_move
	.obj3_stop:
		jp   .chkEnd
	.obj3_move:
		jp   .moveH
; --------------- frame #4 ---------------
.obj4:
	; Heavy-only.
	; Deal the final hit at the end of the frame.
	mMvC_ValFrameEnd .moveH
		mMvC_SetAnimSpeed $01
		mMvC_PlaySound SCT_MOVEJUMP_A
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_HEAVYHIT
		jp   .moveH
; --------------- common horizontal movement / frames #1-5 ---------------
.moveH:
	call OBJLstS_ApplyXSpeed
	jp   .anim
; --------------- frame #6 ---------------
.chkEnd:
	mMvC_ValFrameEnd .anim
		call Play_Pl_EndMove
		jr   .ret
; --------------- common ---------------
.anim:
	call OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
	
; =============== mSeekBirdVar ===============
; Seeks to the specified OBJInfo field for the player's bird.
; Helper for MoveC_Nakoruru_MamahahaFlight.
; IN
; - 1: iOBJInfo_* field
; - DE: Ptr to the current player's wOBJInfo
; OUT
; - DE: Ptr to respective wOBJInfo_Pl*Bird
; - HL: Ptr to the specified field
MACRO mSeekBirdVar
	; DE = Ptr to wOBJInfo_Pl*Bird
	ld   hl, +(OBJINFO_SIZE*4) ; 4 OBJInfo slots ahead from current player
	add  hl, de
	
	; HL = Ptr to its specific field
	push de
		ld   de, \1
		add  hl, de
	pop  de
ENDM
	
; =============== MoveC_Nakoruru_MamahahaFlight ===============
; Move code for Mamahaha Flight (MOVE_NAKORURU_MAMAHAHA_FLIGHT_L, MOVE_NAKORURU_MAMAHAHA_FLIGHT_H).
; This is complex move that can transition to multiple other moves.
MoveC_Nakoruru_MamahahaFlight:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $00, .obj0
		mMvC_ChkFrame $01, .obj1
		mMvC_ChkFrame $02, .obj2
		mMvC_ChkFrame $03, .chkGravity
		mMvC_ChkFrame $04, .chkEnd
		
; --------------- frame #0 ---------------
; Startup.
.obj0:
	mMvC_ValFrameEnd .anim
		mMvC_SetAnimSpeed ANIMSPEED_NONE
		mMvC_PlaySound SFX_JUMP
		
		; Set the initial backjump mode
		ld   hl, iPlInfo_Nakoruru_MamahahaFlight_Mode
		add  hl, bc
		ld   [hl], PBM_CHKCATCH
		; Prepare flight timer mode ($100*2 frames)
		inc  hl ; iPlInfo_Nakoruru_MamahahaFlight_TimeLeft
		ld   [hl], $00
		jp   .anim
		
; --------------- frame #1 ---------------
; Jump frame.
.obj1:
	; At the start of the frame, set the jump settings
	mMvC_ValFrameStartFast .obj1_cont
		;--
		; Remove invuln
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		set  PF0B_AIR, [hl]
		inc  hl
		res  PF1B_INVULN, [hl]
		;--
		mMvC_SetSpeedH -$0100 ; 1px/frame back
		mMvC_SetSpeedV -$0600 ; 6px/frame up
.obj1_cont:
	; Almost immediately try to switch to the next frame.
	; This triggers the frame after the jump starts, and to switch to #2 it takes a few more. 
	; This is enough to position Nakoruru closer to the bird by the time we validate their positions.
	mMvC_NextFrameOnGtYSpeed -$06, ANIMSPEED_NONE
	jp   .chkGravity
	
; --------------- frame #2 ---------------
; Main routine
.obj2:
	; Depending on the current phase...
	ld   hl, iPlInfo_Nakoruru_MamahahaFlight_Mode
	add  hl, bc
	ld   a, [hl]
	cp   PBM_CHKCATCH
	jp   z, .chkCatch
	cp   PBM_FLIGHT
	jp   z, .flight
	jp   .chkGravity
; --------------- frame #2 mode 0 ---------------
; Main routine - Catch validation
.chkCatch:

	;
	; In a single frame verify that it's possible for the bird to catch us.
	; The animation is lined up to have us close to the bird.
	;

	;
	; No projectile must be on-screen.
	; Otherwise, it means the bird is busy acting as one (technically hidden) and can't catch us.
	;
	mMvIn_ValProjActive .catchFail
	
	
	;
	; Nakoruru must be within $10px horizontally from Mamahaha.
	;
	
	; A = Player X Position
	ld   hl, iOBJInfo_X
	add  hl, de
	ld   a, [hl]
	
	; HL = Ptr to Mamahaha's X Position
	ld   hl, +(OBJINFO_SIZE*4)
	add  hl, de
	inc  hl ; to iOBJInfo_OBJLstFlags
	inc  hl ; to iOBJInfo_OBJLstFlagsView
	inc  hl ; to iOBJInfo_X
	
	; A = Distance between X positions
	sub  a, [hl]			; A = PlX - BirdX
	bit  7, a				; A < 0?
	jp   z, .chkCatch_noInv	; If not, skip
	cpl  					; Otherwise, A = -A
	inc  a
.chkCatch_noInv:
	cp   $10				; DistanceX >= $10?
	jp   nc, .catchFail		; If so, catch failed
	
	;
	; Nakoruru must be at most within $18px and $30px below Mamahaha.
	; In practice, she must be on the ground and the bird around the standard Y position.
	;
	
	; A = Player Y Position - $30
	ld   hl, iOBJInfo_Y	; Usually ends up being $54 from the ground
	add  hl, de
	ld   a, [hl]
	sub  a, $30			; Subtracting this shifts the distance checks below.
	
	; HL = Ptr to Mamahaha's Y Position (around $36 usually)
	ld   hl, +(OBJINFO_SIZE*4)
	add  hl, de
	inc  hl ; to iOBJInfo_OBJLstFlags
	inc  hl ; to iOBJInfo_OBJLstFlagsView
	inc  hl ; to iOBJInfo_X
	inc  hl ; to iOBJInfo_XSub
	inc  hl ; to iOBJInfo_Y
	
	; A = Distance between Y positions
	sub  a, [hl]			; A = PlY - BirdY
	; If Nakoruru is more than $30px below the bird, the catch failed.
	; $30px because that's how much was subtracted from the distance.
	bit  7, a				; A (- $30) > 0?
	jp   z, .catchFail		; If so, catch failed (bird is below us)
	; Convert the distance to positive.
	; Because it's shifted down by $30, positions closer to $30 become closer to $00, so...
	cpl  					; A = -A
	inc  a
	; ...if Nakoruru is too close to the bird (*LESS* than $18px below the bird), the catch failed.
	; Because of the aforemented inversion, we check that with an nc/>=.
	cp   $18				; DistanceY (- $30) >= $18?
	jp   nc, .catchFail
	
	;
	; Mamahaha must be in its main gameplay mode (not flying in [Intro] or flying out [Outro])
	;
	mSeekBirdVar iOBJInfo_Bird_Mode ; HL = Ptr to iOBJInfo_Bird_Mode
	ld   a, [hl]					; A = Bird mode
	cp   PLAY_BIRD_MODE_IDLE		; Is he idle?
	jp   nz, .catchFail				; If not, jump
	
	;
	; OK, we reached the bird.
	; We can now continue to the normal flight mode.
	;
	
	; Set the bird in flight mode
	ld   [hl], PLAY_BIRD_MODE_FLIGHT
	
	; Set the player move in flight mode
	ld   hl, iPlInfo_Nakoruru_MamahahaFlight_Mode
	add  hl, bc
	ld   [hl], PBM_FLIGHT
	
	jp   .ret
	
.catchFail:
	; Catch missed!
	; If we get here at any point, switch directly to #3. (our YSpeed is always > -$06)
	mMvC_NextFrameOnGtYSpeed -$06, ANIMSPEED_NONE
	jp   .chkGravity
	
; --------------- frame #2 mode 1 ---------------
; Main routine - flight mode.
.flight:
	
	;
	; Clear the gravity at the start of the frame.
	;
	mMvC_SetSpeedHRaw +$0000
	mMvC_SetSpeedV +$0000
	
	; Set the default animation speed when idle
	; [BUG] Moving in the various directions alters this speed, but jumping off the bird
	;       does *not* reset it to the default value.
	;       This is most noticeable when releasing the bird while holding UP as that sets
	;       a very fast animation speed.
	ld   a, $06
	call .setBirdAnimSpeed
	
	
	;
	; Handle flight movement.
	; You can move in multiple directions at the same time.
	; Each direction sets the bird animation speed to a certain one, with later ones taking priority.
	;
	
	ld   hl, iPlInfo_JoyKeys
	add  hl, bc
	ld   a, [hl]					; A = Held Keys
	
.chkMoveR:
	; Move right at a 0.5px/frame
	; Flap wings every 3 frames
	bit  KEYB_RIGHT, a				; Holding RIGHT?
	jp   z, .chkMoveL				; If not, skip
	push af
		mMvC_SetMoveHAbs +$0080		; Move 0.5px right
		ld   a, $03					; Flap wings every 3 frames
		call .setBirdAnimSpeed
	pop  af
	
.chkMoveL:
	; Move left at a 0.5px/frame
	; Flap wings every 3 frames
	bit  KEYB_LEFT, a
	jp   z, .chkMoveU
	push af
		mMvC_SetMoveHAbs -$0080
		ld   a, $03
		call .setBirdAnimSpeed
	pop  af
	
.chkMoveU:

	;
	; NOTE: Vertical movement is affected by the player already moving downwards $00.10px/frame.
	;
	; The mMvC_SetSpeedV calls account for it, and as a result, the effective vertical movement 
	; speed is $00.70px/frame for both moving up and down.
	;

	; Move up at a $00.70px/frame
	; Flap wings every other frame
	bit  KEYB_UP, a
	jp   z, .chkMoveD
	push af
		mMvC_SetSpeedV -$0070-$0010
		ld   a, $01
		call .setBirdAnimSpeed
	pop  af
	
.chkMoveD:
	; Move down at a $00.70px/frame
	; Flap wings every 8 frames
	bit  KEYB_DOWN, a				; Holding DOWN?
	jp   z, .chkMoveB					; If so, jump
	push af
		mMvC_SetSpeedV +$0070-$0010
		ld   a, $08
		call .setBirdAnimSpeed
	pop  af
	
	;--
	
	;
	; INPUT CHECKS START HERE
	;

.chkMoveDownB:
	;
	; DOWN+B -> Yatoro Pokku (Spin)
	;
	; The "DOWN" check is implicit, since if we got here, we're definitely holding it.
	;
	ld   hl, iPlInfo_JoyKeysLH
	add  hl, bc
	ld   a, [hl]
	bit  KEPB_B_HEAVY, a
	jr   nz, .startSpinMoveH
	bit  KEPB_B_LIGHT, a
	jp   nz, .startSpinMoveL
	jp   .chkMoveA
	
.chkMoveB:
	;
	; B -> Kamui Mutsube (Diagonal Dive)
	;
	ld   hl, iPlInfo_JoyKeysLH
	add  hl, bc
	ld   a, [hl]
	bit  KEPB_B_HEAVY, a
	jr   nz, .startDiagDiveH
	bit  KEPB_B_LIGHT, a
	jp   nz, .startDiagDiveL
	
.chkMoveA:

	;
	; A -> Hopped off bird
	;
	ld   hl, iPlInfo_JoyKeysLH
	add  hl, bc
	ld   a, [hl]
	bit  KEPB_A_HEAVY, a
	jr   nz, .startFall
	bit  KEPB_A_LIGHT, a
	jr   nz, .startFall
	
	;--
	
	;
	; If still holding on the bird when the round ends, drop off.
	; This can only happen when reflecting a projectile that KOs the opponent
	; and hopping on the bird shortly before.
	;
	call ExOBJ_Bird_IsRoundOverNoSuper
	jp   c, .startFall
	
	
	;--
	
	;
	; Decrement the bird flight timer every other frame.
	; When it elapses, we automatically release.
	;
	; This means, considering the timer is set to $00 at first, you can stay on the bird
	; for $200 frames. (512 frames, around 8.5 seconds)
	;
	
	; [POI] In POWERUP mode, bird time is infinite. Enjoy the timer scam.
	ld   a, [wDipSwitch]
	bit  DIPB_POWERUP, a
	jp   nz, .doFlightGravity
	
	; Every other frame...
	ld   a, [wTimer]
	and  a, $01					; wTimer % 2 != 0?
	jp   nz, .doFlightGravity	; If so, skip
	
	; iPlInfo_Nakoruru_MamahahaFlight_TimeLeft--
	ld   hl, iPlInfo_Nakoruru_MamahahaFlight_TimeLeft
	add  hl, bc
	dec  [hl]
	
	; If it elapsed, release
	jp   z, .startFall
	
	;--
	
.doFlightGravity:
	; Move down 0.0625px/frame.
	; If touching the ground, release.
	mMvC_DoGravityHV $0010		; Touched the ground?
	jp   c, .startFall			; If so, jump
	
	jp   .ret
.startFall:

	;
	; Release the bird by jumping off (switching to #3)
	;

	; Switch the bird to its main mode
	mSeekBirdVar iOBJInfo_Bird_Mode ; HL = Ptr to iOBJInfo_Bird_Mode
	ld   [hl], PLAY_BIRD_MODE_IDLE
	
	; Start the straight down drop. (switch to #3)
	;
	; Frame changes aren't instantaneous as the graphics need to load, so if we
	; were to just set the new frame, we'd still be in #2's flight mode for a bit. That would be bad.
	; To get around that, it also sets PBM_FALL, which causes #2's handler to jump to #3's code.
	ld   hl, iPlInfo_Nakoruru_MamahahaFlight_Mode
	add  hl, bc
	ld   [hl], PBM_FALL
	mMvC_SetFrame $03, ANIMSPEED_NONE
	
	jp   .ret
	;--
	
	;
	; Release the bird by switching to another move.
	;
.startSpinMoveL:
	ld   a, MOVE_NAKORURU_YATORO_POKKU_L
	jp   .startNewMove
.startSpinMoveH:
	ld   a, MOVE_NAKORURU_YATORO_POKKU_H
	jp   .startNewMove
.startDiagDiveL:
	ld   a, MOVE_NAKORURU_KAMUI_MUTSUBE_L
	jp   .startNewMove
.startDiagDiveH:
	ld   a, MOVE_NAKORURU_KAMUI_MUTSUBE_H
.startNewMove:
	call MoveInputS_SetSpecMove_StopSpeed
	
	; Release the bird
	mSeekBirdVar iOBJInfo_Bird_Mode ; HL = Ptr to iOBJInfo_Bird_Mode
	ld   [hl], PLAY_BIRD_MODE_IDLE
	
	;--
	; [POI] Copy/paste? We're starting another move, this isn't used...
	ld   hl, iPlInfo_Nakoruru_MamahahaFlight_Mode
	add  hl, bc
	ld   [hl], PBM_FALL
	;--
	
	jp   .ret
	
; --------------- .setBirdAnimSpeed ---------------
; Sets a new animation speed for Mamahaha.
; IN:
; - A: Animation speed
.setBirdAnimSpeed:
	mSeekBirdVar iOBJInfo_FrameTotal	; HL = ptr to iOBJInfo_FrameTotal
	ld   [hl], a 						; Write the new value
	ret
	
; --------------- common gravity check / multipurpose ---------------
; Used when:
; - In the initial backjump, if the bird isn't there to catch us yet
; - Releasing the bird and falling staight down.
.chkGravity:

	; When touching the ground...
	mMvC_ChkGravityHV $0060, .anim
		;--
		; ...allow special cancelling
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		res  PF0B_AIR, [hl]
		inc  hl
		res  PF1B_NOSPECSTART, [hl]
		;--
		; ...switch to #5
		mMvC_SetLandFrame $04, $05
		jp   .ret
; --------------- frame #4 ---------------
; Normal hop off - Recovery after landing on the ground.
.chkEnd:
	mMvC_ValFrameEnd .anim
		call Play_Pl_EndMove
		jr   .ret
; --------------- common ---------------
.anim:
	call OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Nakoruru_YatoroPokku ===============
; Move code for Nakoruru's Yatoro Pokku (Spin) (MOVE_NAKORURU_YATORO_POKKU_L, MOVE_NAKORURU_YATORO_POKKU_H).
MoveC_Nakoruru_YatoroPokku:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $00, .obj0
		mMvC_ChkFrame $01, .obj1
		mMvC_ChkFrame $02, .setDamage0
		mMvC_ChkFrame $03, .setDamage1
		mMvC_ChkFrame $04, .setDamage0
		mMvC_ChkFrame $05, .setDamageEnd
		mMvC_ChkFrame $06, .chkEnd
	jp   .anim ; We never get here
; --------------- frame #0 ---------------
.obj0:
	mMvC_ValFrameEnd .anim
		mMvC_SetAnimSpeed ANIMSPEED_INSTANT
		jp   .anim
; --------------- frame #1 ---------------
.obj1:
	mMvC_ValFrameStartFast .obj1_cont
		mMvC_PlaySound SCT_MOVEJUMP_A
		; Set dive trajectory
		mMvC_ChkMove MOVE_NAKORURU_YATORO_POKKU_H, .obj1_setJumpH
	.obj1_setJumpL: ; Light
		mMvC_SetSpeedH +$0080
		mMvC_SetSpeedV +$0080
		jp   .obj1_cont
	.obj1_setJumpH: ; Heavy
		mMvC_ChkMaxPow .obj1_setJumpE
		mMvC_SetSpeedH +$0100
		mMvC_SetSpeedV +$0100
		jp   .obj1_cont
	.obj1_setJumpE: ; Max Power Heavy
		mMvC_SetSpeedH +$0100
		mMvC_SetSpeedV -$0300
.obj1_cont:
	; [POI] All of the hits deal knockdowns, which causes them to move backwards and up.
	;       .setDamage0 and .setDamage1 in particular contain duplicate code.
	mMvC_ValFrameEnd .chkGravity
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_SUPERALT
		jp   .chkGravity
; --------------- frames #2,4 ---------------
.setDamage0:
	mMvC_ValFrameEnd .chkGravity
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_SUPERALT
		jp   .chkGravity
; --------------- frame #3 ---------------
.setDamage1:
	mMvC_ValFrameEnd .chkGravity
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_SUPERALT
		jp   .chkGravity
; --------------- frame #5 ---------------
.setDamageEnd:
	mMvC_ValFrameEnd .chkGravity
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_SUPERALT
		mMvC_SetFrameOnEnd $02
		jp   .chkGravity
; --------------- frame #3 ---------------
.chkGravity:
	; Move at a lower gravity than usual. When landing on the ground, switch to #6
	mMvC_ChkGravityHV $0018, .anim
		;--
		; Allow special cancel
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		res  PF0B_AIR, [hl]
		inc  hl
		res  PF1B_NOSPECSTART, [hl]
		;--
		; Long recovery.
		mMvC_SetLandFrame $06, $14
		jp   .ret
; --------------- frame #3 ---------------
; Recovery
.chkEnd:
	; Slow down on the ground, which is almost imperceptible
	mMvC_DoFrictionH $0040
	mMvC_ValFrameEnd .anim
		call Play_Pl_EndMove
		jr   .ret
; --------------- common ---------------
.anim:
	call OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Nakoruru_KamuiMutsube ===============
; Move code for Nakoruru's Kamui Mutsube (Downwards Dash) (MOVE_NAKORURU_KAMUI_MUTSUBE_L, MOVE_NAKORURU_KAMUI_MUTSUBE_H).
; See also: MoveC_Nakoruru_YatoroPokku
MoveC_Nakoruru_KamuiMutsube:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $00, .obj0
		mMvC_ChkFrame $01, .obj1
		mMvC_ChkFrame $02, .setDamage0
		mMvC_ChkFrame $03, .setDamage1
		mMvC_ChkFrame $04, .setDamage0
		mMvC_ChkFrame $05, .setDamageEnd
		mMvC_ChkFrame $06, .chkEnd
	jp   .anim ; We never get here
; --------------- frame #0 ---------------
.obj0:
	mMvC_ValFrameEnd .anim
		mMvC_SetAnimSpeed ANIMSPEED_INSTANT
		jp   .anim
; --------------- frame #1 ---------------
.obj1:
	mMvC_ValFrameStartFast .obj1_cont
		mMvC_PlaySound SCT_MOVEJUMP_A
		
		; Set dive trajectory
	IF FIX_BUGS == 1
		mMvC_ChkMove MOVE_NAKORURU_KAMUI_MUTSUBE_H, .obj1_setJumpH
	ELSE
		ld   hl, iPlInfo_MoveId
		add  hl, bc
		ld   a, [hl]
		;--
		; [POI] Was this move supposed to handle both? Either that, or a copy/paste error.
		cp   MOVE_NAKORURU_YATORO_POKKU_H
		jp   z, .obj1_setJumpH
		;--
		cp   MOVE_NAKORURU_KAMUI_MUTSUBE_H
		jp   z, .obj1_setJumpH
	ENDC
	.obj1_setJumpL: ; Light
		mMvC_SetSpeedH +$0300
		mMvC_SetSpeedV +$0300
		jp   .obj1_cont
	.obj1_setJumpH: ; Heavy
		mMvC_ChkMaxPow .obj1_setJumpE
		mMvC_SetSpeedH +$0500
		mMvC_SetSpeedV +$0300
		jp   .obj1_cont
	.obj1_setJumpE: ; Max Power Heavy
		mMvC_SetSpeedH +$0700
		mMvC_SetSpeedV +$0200
.obj1_cont:
	; [POI] All of the hits deal knockdowns, which causes them to move backwards and up.
	;       .setDamage0 and .setDamage1 in particular contain duplicate code.
	mMvC_ValFrameEnd .chkGravity
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_SUPERALT
		jp   .chkGravity
; --------------- frames #2,4 ---------------
.setDamage0:
	mMvC_ValFrameEnd .chkGravity
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_SUPERALT
		jp   .chkGravity
; --------------- frame #3 ---------------
.setDamage1:
	mMvC_ValFrameEnd .chkGravity
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_SUPERALT
		jp   .chkGravity
; --------------- frame #5 ---------------
.setDamageEnd:
	mMvC_ValFrameEnd .chkGravity
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_CONTHIT|PF3_SUPERALT
		mMvC_SetFrameOnEnd $02
		jp   .chkGravity
; --------------- frame #3 ---------------
.chkGravity:
	; Move at a lower gravity than usual. When landing on the ground, switch to #6
	mMvC_ChkGravityHV $0018, .anim
		;--
		; Allow special cancel
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		res  PF0B_AIR, [hl]
		inc  hl
		res  PF1B_NOSPECSTART, [hl]
		;--
		; Long recovery.
		mMvC_SetLandFrame $06, $14
		jp   .ret
; --------------- frame #3 ---------------
; Recovery
.chkEnd:
	; Slow down on the ground
	mMvC_DoFrictionH $0040
	mMvC_ValFrameEnd .anim
		call Play_Pl_EndMove
		jr   .ret
; --------------- common ---------------
.anim:
	call OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== MoveC_Nakoruru_ElerushKamuiRimse ===============
; Move code for Elerush Kamui Rimse (Super Cape Swing) (MOVE_NAKORURU_ELERUSH_KAMUI_RIMSE_S).
MoveC_Nakoruru_ElerushKamuiRimse:
	call Play_Pl_MoveByColiBoxOverlapX
	mMvC_ValLoaded .ret
	
	; Depending on the visible frame...
	mMvC_StartChkFrame
		mMvC_ChkFrame $00, .obj0
		mMvC_ChkFrame $01, .obj1
		mMvC_ChkFrame $02, .obj2
		mMvC_ChkFrame $03, .obj3_chkGuard
		mMvC_ChkFrame $04, .setDamage0
		mMvC_ChkFrame $05, .setDamage1
		mMvC_ChkFrame $06, .setDamage2
		mMvC_ChkFrame $07, .setDamage0
		mMvC_ChkFrame $08, .setDamage1
		mMvC_ChkFrame $09, .setDamage2
		mMvC_ChkFrame $0A, .setDamage0
		mMvC_ChkFrame $0B, .setDamage1
		mMvC_ChkFrame $0C, .setDamage2
		mMvC_ChkFrame $0D, .setDamage3
		mMvC_ChkFrame $0E, .setDamage4
		mMvC_ChkFrame $0F, .setDamageLast
		mMvC_ChkFrame $10, .obj10
		mMvC_ChkFrame $11, .doGravity
		mMvC_ChkFrame $12, .doGravity
		mMvC_ChkFrame $13, .obj13
		mMvC_ChkFrame $14, .obj14
		mMvC_ChkFrame $15, .chkEnd
		mMvC_ChkFrame $16, .chkEndFail
	jp   .anim ; We never get here
; --------------- frame #0 ---------------
; Startup
.obj0:
	mMvC_ValFrameEnd .anim
		; Immediately try to switch from #2 to #3, which works with the "mMvC_SetSpeedV -$0700"
		mMvC_SetAnimSpeed ANIMSPEED_INSTANT
		mMvC_PlaySound SCT_MOVEJUMP_A
		; Register the initial hit we deal when hopefully getting close to the opponent in #3
		mMvC_SetDamageNext $04, HITTYPE_HIT_MULTI1, PF3_CONTHIT
		jp   .anim
; --------------- frame #1 ---------------
; Initial jump, moving up.
.obj1:
	; The initial jump is special in that it handles its peak manually.
	; At the start of the frame, the player is set to jump directly up at a very fast speed.
	;
	; The previously set ANIMSPEED_INSTANT cuts short how much we actually jump up, and the
	; next frame sets a fast dive forward.
	
	mMvC_ValFrameStartFast .obj1_cont
		;--
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		set  PF0B_AIR, [hl]
		;--
		; Jump directly up
		mMvC_SetSpeedH +$0000
		mMvC_SetSpeedV -$0700
.obj1_cont:
	; Apply little gravity
	mMvC_DoGravityHV +$0060
	jp   .anim
; --------------- frame #2 ---------------
.obj2:
	; Immediately set the dive speed at the start (see above)
	mMvC_ValFrameStartFast .obj2_cont
		mMvC_SetSpeedH +$0700
		mMvC_SetSpeedV +$0300
		;--
		; Remove invulnerability
		ld   hl, iPlInfo_Flags1
		add  hl, bc
		res  PF1B_INVULN, [hl]
		;--
.obj2_cont:
	mMvC_DoGravityHV $0000
	jp   .anim
; --------------- hit check / frame #3 ---------------
.obj3_chkGuard:
	;
	; Continue going through the dive until we hit the unguarded opponent.
	; This works with the damage settings we previously set in #0, if the
	; opponent got hit by that it will be notified to us.
	;
	ld   hl, iPlInfo_ColiFlags
	add  hl, bc
	bit  PCFB_HITOTHER, [hl]			; Did we reach?
	jp   z, .obj3_chkGuard_noHit		; If not, skip
	ld   hl, iPlInfo_Flags1Other
	add  hl, bc
	bit  PF1B_INVULN, [hl]				; Is the opponent invulnerable?
	jp   nz, .obj3_chkGuard_noHit		; If so, skip
	bit  PF1B_HITRECV, [hl]				; Did the opponent get hit?
	jp   z, .obj3_chkGuard_noHit		; If not, skip	
	
	bit  PF1B_GUARD, [hl]				; Is the opponent blocking?
	jp   nz, .obj3_chkGuard_noHit		; If not, skip	
	
	.obj3_chkGuard_confirmed:
		; Opponent got hit, continue the damage string to #4, animated as fast as possible
		mMvC_SetDamageNext $04, HITTYPE_HIT_MULTI1, PF3_CONTHIT
		mMvC_SetFrame $04, ANIMSPEED_INSTANT
		mMvC_SetSpeedH +$0000
		; Align to floor
		ld   hl, iOBJInfo_Y
		add  hl, de
		ld   [hl], PL_FLOOR_POS
		jp   .ret
.obj3_chkGuard_noHit:
	; If we didn't reach the opponent (or they blocked) by the time we stop moving,
	; switch to #16 and end the move.
	mMvC_ChkGravityHV $0000, .ret
		mMvC_SetLandFrame $16, $0A
		; Intentionally make us slide for punishment
		mMvC_SetSpeedH $0400
		jp   .ret
		
; --------------- frames #4,7,A ---------------
; Damage sequence, looped frame #0
.setDamage0:
	mMvC_ValFrameEnd .anim
		mMvC_SetDamageNext $02, HITTYPE_HIT_MULTI0, PF3_CONTHIT|PF3_SUPERALT
		jp   .anim
; --------------- frames #5,8,B ---------------
; Damage sequence, looped frame #1
.setDamage1:
	mMvC_ValFrameEnd .anim
		mMvC_SetDamageNext $02, HITTYPE_HIT_MULTI1, PF3_CONTHIT|PF3_SUPERALT
		jp   .anim
; --------------- frames #6,9,C ---------------
; Damage sequence, looped frame #2
.setDamage2:
	mMvC_ValFrameEnd .anim
		mMvC_SetDamageNext $02, HITTYPE_HIT_MULTI0, PF3_CONTHIT|PF3_SUPERALT
		jp   .anim
; --------------- frame #D ---------------
; Damage sequence, final phys hit #0
.setDamage3:
	mMvC_ValFrameEnd .anim
		mMvC_SetDamageNext $08, HITTYPE_LAUNCH_HIGH_UB, PF3_HEAVYHIT|PF3_CONTHIT|PF3_HALFSPEED|PF3_SUPERALT
		jp   .anim
; --------------- frame #E ---------------
; Damage sequence, final phys hit #1
.setDamage4:
	mMvC_ValFrameEnd .anim
		mMvC_SetDamageNext $04, HITTYPE_LAUNCH_HIGH_UB, PF3_HEAVYHIT|PF3_CONTHIT|PF3_HALFSPEED|PF3_SUPERALT
		jp   .anim
; --------------- frame #F ---------------
; Damage sequence, final phys hit #2
.setDamageLast:
	mMvC_ValFrameEnd .anim
		mMvC_SetDamageNext $01, HITTYPE_LAUNCH_HIGH_UB, PF3_HEAVYHIT|PF3_CONTHIT
		jp   .anim
; --------------- frame #10 ---------------
; Backjump away.
.obj10:
	; At the start, jump away in preparation for the bird throw
	mMvC_ValFrameStartFast .doGravity
		;--
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		set  PF0B_AIR, [hl]
		;--
		mMvC_SetSpeedH -$0280 ; -2.5px/frame back
		mMvC_SetSpeedV -$0400 ; 4px/frame up
; --------------- common gravity check / frames #10-12 ---------------
.doGravity:
	; Wait for the backjump to reach the ground.
	; Switch to #13 when that happens.
	mMvC_ChkGravityHV $00C0, .anim
		;--
		; Allow special cancel
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		res  PF0B_AIR, [hl]
		inc  hl
		res  PF1B_NOSPECSTART, [hl]
		;--
		; Stay in the landing frame as little as possible
		mMvC_SetLandFrame $13, ANIMSPEED_INSTANT
		jp   .ret
; --------------- frame #13 ---------------
.obj13:
	; Intermediate frame when landing on the ground
	mMvC_ValFrameStartFast .anim
		;--
		; Allow special cancel
		ld   hl, iPlInfo_Flags0
		add  hl, bc
		res  PF0B_AIR, [hl]
		inc  hl
		res  PF1B_NOSPECSTART, [hl]
		;--
		; Align to floor
		ld   hl, iOBJInfo_Y
		add  hl, de
		ld   [hl], PL_FLOOR_POS
		jp   .anim
; --------------- frame #14 ---------------
.obj14:
	; Throw the bird, dealing massive damage
	mMvC_ValFrameStartFast .obj14_cont
		call ProjInit_Nakoruru_Bird
.obj14_cont:
	; Wait for $2D frames in the throw pose, long enough for the bird to come back.
	mMvC_ValFrameEnd .anim
		mMvC_SetAnimSpeed $2D
		jp   .anim
; --------------- frame #15 ---------------
; Recovery - when the move got to the end.
.chkEnd:
	mMvC_ValFrameEnd .anim
		call Play_Pl_EndMove
		jr   .ret
; --------------- frame #16 ---------------
; Recovery - when the move failed to hit the opponent once.
;            (only the initial jump happened)
.chkEndFail:
	; That jump has momentum coming from it, making it punishable
	mMvC_DoFrictionH $0040
	mMvC_ValFrameEnd .anim
		call Play_Pl_EndMove
		jr   .ret
; --------------- common ---------------
.anim:
	call OBJLstS_DoAnimTiming_Loop_by_DE
.ret:
	ret
	
; =============== ProjInit_Nakoruru_Bird ===============
; Initializes the projectile version of Mamahaha, for Nakoruru's:
; - Amube Yatoro (Bird Throw) (MOVE_NAKORURU_AMUBE_YATORO_L, MOVE_NAKORURU_AMUBE_YATORO_H)
; - Super Move (MOVE_NAKORURU_ELERUSH_KAMUI_RIMSE_S)
;
; To simplify the code, the projectile version of Mamahaha is an entirely separate entity from the normal one,
; so the normal Mamahaha gets hidden while the projectile is visible.
ProjInit_Nakoruru_Bird:
	mMvC_PlaySound SCT_PROJ_LG_B

	push bc
		push de

			; --------------- common projectile init code ---------------

			;
			; C flag = If set, we're at max power
			;
			ld   hl, iPlInfo_Pow
			add  hl, bc
			ld   a, [hl]		; A = Pow meter
			cp   PLAY_POW_MAX	; Are we at max power?
			jp   z, .initMaxPow	; If so, jump
			xor  a				; C flag clear
			jp   .getFlags2
		.initMaxPow:
			scf					; C flag set
		.getFlags2:
		
			;
			; A = Move ID
			;
			ld   hl, iPlInfo_MoveId
			push af				; Preserve C flag for this
				add  hl, bc		; Seek to iPlInfo_MoveId
			pop  af
			ld   a, [hl]		; Read out to A
			push af ; Save A & C flag
			
				; =============== ProjInitS_InitAndGetOBJInfo ===============
				; Gets the projectile's wOBJInfo for the current player and initializes its common properties.
				;
				; Extracted to ProjInitS_InitAndGetOBJInfo in 96.
				;
				; IN
				; - BC: Ptr to wPlInfo
				; - DE: Ptr to respective wOBJInfo
				; OUT
				; - DE: Ptr to projectile wOBJInfo (wOBJInfo_Pl*Projectile)
				; WIPES
				; - BC
				
				;
				; A = Player marker (for the tile ID check)
				;
				ld   hl, iPlInfo_PlId
				add  hl, bc
				ld   a, [hl]
			
				;--
				; [POI] Altered logic from the canonical ProjInitS_InitAndGetOBJInfo.
				
				push af
				
					;
					; As usual, seek to the wOBJInfo for the current player's projectile.
					; This will either be a Ptr to wOBJInfo_Pl1Projectile or a Ptr to wOBJInfo_Pl2Projectile.
					; Save its ptr to DE and HL.
					;
					push de			; BC = Ptr to player wOBJInfo
					pop  bc
					ld   hl, (OBJINFO_SIZE*2)+iOBJInfo_Status
					add  hl, bc		; Seek to 2 slots after
					push hl
					pop  de			; Copy it to DE
					
					;
					; Also seek to the wOBJInfo for the current player's Mamahaha.
					; This will either be a Ptr to wOBJInfo_Pl1Bird or a Ptr to wOBJInfo_Pl2Bird.
					; Save its ptr to BE.
					;
					ld   bc, (OBJINFO_SIZE*2)+iOBJInfo_Status	; Take the HL pointer and seek to 2 slots after
					add  hl, bc
					push hl
					pop  bc										; Copy it to BE
					
					;
					; Hide the ExOBJ version of Mamahaha.
					;	
					xor  a
					ld   [bc], a
					
					;
					; Show the projectile version of Mamahaha.
					;
					ld   a, OST_VISIBLE
					ld   [de], a
				pop  af
				;--
	
				;
				; Set the tile ID base for the projectile depending on the player we're playing as.
				; The values must be consistent with that's written in Play_LoadProjectileOBJInfo
				;
				or   a				; iPlInfo_PlId != PL1?
				jp   nz, .tileId2P	; If so, jump
			.tileId1P:
				ld   hl, iOBJInfo_TileIDBase
				add  hl, de		; Seek to iOBJInfo_TileIDBase
				ld   [hl], $80	; Graphics from $8800
				jp   .tileIdRet
			.tileId2P:
				ld   hl, iOBJInfo_TileIDBase
				add  hl, de		; Seek to iOBJInfo_TileIDBase
				ld   [hl], $A4	; Graphics from $8A40
			.tileIdRet:
				; ==============================
			

				; --------------- main ---------------

				; Set code pointer
				ld   hl, iOBJInfo_Play_CodeBank
				add  hl, de
				ld   [hl], BANK(ProjC_Nakoruru_Bird)	; BANK $16 ; iOBJInfo_Play_CodeBank
				inc  hl
				ld   [hl], LOW(ProjC_Nakoruru_Bird)	; iOBJInfo_Play_CodePtr_Low
				inc  hl
				ld   [hl], HIGH(ProjC_Nakoruru_Bird)	; iOBJInfo_Play_CodePtr_High

				; Write sprite mapping ptr for this projectile.
				ld   hl, iOBJInfo_BankNum
				add  hl, de
				ld   [hl], BANK(OBJLstPtrTable_Proj_Nakoruru_Bird)	; BANK $01 ; iOBJInfo_BankNum
				inc  hl
				ld   [hl], LOW(OBJLstPtrTable_Proj_Nakoruru_Bird)	; iOBJInfo_OBJLstPtrTbl_Low
				inc  hl
				ld   [hl], HIGH(OBJLstPtrTable_Proj_Nakoruru_Bird)	; iOBJInfo_OBJLstPtrTbl_High
				inc  hl
				ld   [hl], $00	; iOBJInfo_OBJLstPtrTblOffset


				; Set animation speed.
				ld   hl, iOBJInfo_FrameLeft
				add  hl, de
				ld   [hl], $00	; iOBJInfo_FrameLeft
				inc  hl
				ld   [hl], ANIMSPEED_INSTANT	; iOBJInfo_FrameTotal

				; Set priority value
				ld   hl, iOBJInfo_Play_Priority
				add  hl, de
				ld   [hl], $01

				; Set initial position relative to the player's origin
		
				; =============== OBJLstS_Overlap ===============
				; Moves an wBJInfo to exactly overlap another one.
				; This copies the coordinates and OBJLstFlags from the source (BC) to destination (DE).
				;
				; Extracted to OBJLstS_Overlap in 96.
				;
				; IN
				; - DE: Ptr to the wOBJInfo structure to be moved
				; - BC: Ptr to target wOBJInfo structure (the "other" one)
				push bc
					;
					; Set up source and destination pointers
					;

					; BC = Ptr to source iOBJInfo_X
					ld   hl, iOBJInfo_X
					add  hl, bc			; HL = BC + iOBJInfo_X
					push hl
					pop  bc				; Move back to BC

					; DE = Ptr to destination iOBJInfo_X
					ld   hl, iOBJInfo_X
					add  hl, de			; HL = DE + iOBJInfo_X

					;
					; Copy the next 4 bytes over (iOBJInfo_X-iOBJInfo_YSub)
					;
			REPT 4
					ld   a, [bc]	; A = Source byte
					inc  bc			; SrcPtr++
					ldi  [hl], a	; Write to dest; DestPtr++
			ENDR
				pop  bc

				;
				; Copy over the byte with sprite mapping flags
				;

				; A = Source iOBJInfo_OBJLstFlags
				ld   hl, iOBJInfo_OBJLstFlags
				add  hl, bc
				ld   a, [hl]
				; HL = Ptr to dest iOBJInfo_OBJLstFlags
				ld   hl, iOBJInfo_OBJLstFlags
				add  hl, de
				; Write it over
				ld   [hl], a
				; ==============================
				
				mMvC_SetMoveH +$0C00 ; 12px in front of the player
			pop  af	; Restore A & C flag

			;
			; Determine the projectile speed.
			; There are a few different settings depending on the move we came from.
			;

			jp   nc, .fldMaxPow
			cp   MOVE_NAKORURU_ELERUSH_KAMUI_RIMSE_S	; Are we doing the super?
			jp   z, .fldSuper							; If so, jump
			cp   MOVE_NAKORURU_AMUBE_YATORO_H			; Was this an heavy attack?
			jp   z, .fldHeavy							; If so, jump
			jp   .fldLight
		.fldMaxPow:
			cp   MOVE_NAKORURU_ELERUSH_KAMUI_RIMSE_S	; Are we doing the super?
			jp   z, .fldSuper							; If so, jump
			cp   MOVE_NAKORURU_AMUBE_YATORO_H			; Was this an heavy attack?
			jp   z, .fldHeavyMaxPow						; If so, jump
		.fldLight:
			mMvC_SetSpeedH +$0200 ; 2px/frame forward
			mMvC_SetSpeedV +$0200 ; 2px/frame downwards
			jp   .end
		.fldHeavyMaxPow:
			mMvC_SetSpeedH +$0400 ; 4px/frame forward
			mMvC_SetSpeedV +$0200 ; 2px/frame downwards
			jp   .end
		.fldHeavy:
			mMvC_SetSpeedH +$0600 ; 6px/frame forward
			mMvC_SetSpeedV +$0200 ; 2px/frame downwards
			jp   .end
		.fldSuper:
			mMvC_SetSpeedH +$0800 ; 8px/frame forward
			mMvC_SetSpeedV +$0380 ; 3.5px/frame downwards
			jp   .end
		.end:

		pop  de
	pop  bc
	ret
	
; =============== ProjC_Nakoruru_Bird ===============
; Code for the projectile version of Mamahaha.
; IN
; - DE: Ptr to wOBJInfo_Pl*Projectile
ProjC_Nakoruru_Bird:
	
	; Move the projectile horizontally
	call .moveH			; Reached the target?
	jp   c, .despawn	; If so, despawn it
	
	; Move the projectile vertically.
	mMvC_ChkGravityV $0000, .despawn ; Reached the ground? If so, despawn it
	
	; Otherwise, continue animating.
	call OBJLstS_DoAnimTiming_Loop_by_DE
	ret
	
.despawn:
	; First, despawn the actual projectile
	call OBJLstS_Hide
	
	;
	; Then, show the normal Mamahaha and move it over the projectile's position.
	; Mamahaha's normal movement code will automatically handle returning to its proper position.
	;
	push bc
		push de
			; HL = Ptr to wOBJInfo_Pl*Bird
			ld   hl, (OBJINFO_SIZE*2)+iOBJInfo_Status ; 2 slots after the projectile
			add  hl, de
			
			; Display normal Mamahaha
			ld   [hl], OST_VISIBLE
			
			;
			; Copy the coordinates from the projectile to the tbird.
			; This works because despawning a projectile doesn't delete its properties.
			;
			
			; BC = Ptr to wOBJInfo_Pl*Projectile (Source)
			push de	; BC = DE
			pop  bc
			; DE = Ptr to wOBJInfo_Pl*Bird (Destination)
			push hl	; DE = HL
			pop  de
			
			push bc
				; Seek to the projectile's X position
				ld   hl, iOBJInfo_X
				add  hl, bc
				push hl
				pop  bc
				
				; Seek to the bird's X position
				ld   hl, iOBJInfo_X
				add  hl, de
				
				; Copy the 4 bytes over (iOBJInfo_X - iOBJInfo_SpeedYSub)
			REPT 4
				ld   a, [bc]	; Read from proj
				inc  bc			; ProjPtr++
				ldi  [hl], a	; Write to bird, birdPtr++
			ENDR

				; Clear the bird's existing speed
				xor  a
				ldi  [hl], a ; iOBJInfo_SpeedX
				ldi  [hl], a ; iOBJInfo_SpeedXSub
				ldi  [hl], a ; iOBJInfo_SpeedY
				ldi  [hl], a ; iOBJInfo_SpeedYSub
			pop  bc
		pop  de
	pop  bc
	ret
	
; =============== .moveH ===============
; Moves the projectile horizontally until it reaches the target.
; The target being either the edge of the screen, or if it hits something.
; IN
; - DE: Ptr to wOBJInfo_Pl*Projectile
; OUT
; - C: If set, 
.moveH:

	;
	; EDGE CHECK
	;
	; If the bird reaches either edge of the screen, we're done.
	;
	ld   hl, iOBJInfo_RelX
	add  hl, de
	ld   a, [hl]					; A = Bird Rel.X Pos
	cp   OBJ_OFFSET_X-1				; A < $07?
	jp   c, .retDespawn				; If so, jump
	cp   SCREEN_H+OBJ_OFFSET_X+1	; A > $A8?
	jp   nc, .retDespawn			; If so, jump
	
	;
	; HIT CHECK
	;
	; If the projectile got hit or was reflected, we're also done.
	; This projectile can't be reflected, but it doesn't stop moves from trying.
	;

	; [TCRF] If the projectile is set to not despawn, which it never is, ignore 
	;        the check and allow it to phase through the opponent.
	;        Presumably the super move would have set this at some point.
	ld   hl, iOBJInfo_Play_Priority
	add  hl, de
	ld   a, [hl]
	cp   PROJ_PRIORITY_NODESPAWN	; Can the projectile despawn on hit?
	jp   z, .retMove				; If not, skip (never taken)
	
	ld   hl, iOBJInfo_Play_HitMode
	add  hl, de
	ld   a, [hl]
	cp   PHM_REMOVE					; Did the projectile hit the opponent?
	jp   z, .retDespawn				; If so, despawn it
	cp   PHM_REFLECT				; Did the opponent attempt to reflect it?	
	jp   z, .retDespawn				; If so, despawn it
.retMove:
	call OBJLstS_ApplyXSpeed
	xor  a	; C flag clear
	ret  
.retDespawn:
	scf		; C flag set
	ret
	
; =============== Play_SpawnBird ===============
; Spawns Mamahaha.
; IN
; - DE: Ptr to the player wOBJInfo
Play_SpawnBird:
	push bc
		push de
			; =============== ProjInitS_InitAndGetOBJInfo ===============
			; Gets the projectile's wOBJInfo for the current player and initializes its common properties.
			;
			; Extracted to ProjInitS_InitAndGetOBJInfo in 96.
			;
			; IN
			; - BC: Ptr to wPlInfo
			; - DE: Ptr to respective wOBJInfo
			; OUT
			; - DE: Ptr to projectile wOBJInfo (wOBJInfo_Pl*Projectile)
			; WIPES
			; - BC
			
			;
			; A = Player marker (for the tile ID check)
			;
			ld   hl, iPlInfo_PlId
			add  hl, bc
			ld   a, [hl]

			;
			; Seek to the wOBJInfo for the current player's extra object slot.
			; Save its ptr to DE and HL.
			;
			; Worth nothing that the slot the bird uses was reused for the super
			; sparkle object in 96, which didn't exist in this game.
			;
			push de			; BC = Ptr to player wOBJInfo
			pop  bc
			ld   hl, (OBJINFO_SIZE*4)+iOBJInfo_Status
			add  hl, bc		; Seek to 4 slots after
			push hl
			pop  de			; Copy it to DE

			;
			; Show the projectile
			;
			ld   [hl], OST_VISIBLE
			
			;
			; Set the tile ID base for the projectile depending on the player we're playing as.
			; The values must be consistent with that's written in Play_LoadProjectileOBJInfo
			;
			or   a				; iPlInfo_PlId != PL1?
			jp   nz, .tileId2P	; If so, jump
		.tileId1P:
			ld   hl, iOBJInfo_TileIDBase
			add  hl, de		; Seek to iOBJInfo_TileIDBase
			ld   [hl], $80	; Graphics from $8800
			jp   .tileIdRet
		.tileId2P:
			ld   hl, iOBJInfo_TileIDBase
			add  hl, de		; Seek to iOBJInfo_TileIDBase
			ld   [hl], $A4	; Graphics from $8A40
		.tileIdRet:
			; ==============================
		

			; --------------- main ---------------

			; Set code pointer
			ld   hl, iOBJInfo_Play_CodeBank
			add  hl, de
			ld   [hl], BANK(ExOBJ_Bird)	; BANK $16 ; iOBJInfo_Play_CodeBank
			inc  hl
			ld   [hl], LOW(ExOBJ_Bird)	; iOBJInfo_Play_CodePtr_Low
			inc  hl
			ld   [hl], HIGH(ExOBJ_Bird)	; iOBJInfo_Play_CodePtr_High

			; Write sprite mapping ptr for this projectile.
			ld   hl, iOBJInfo_BankNum
			add  hl, de
			ld   [hl], BANK(OBJLstPtrTable_Bird)	; BANK $01 ; iOBJInfo_BankNum
			inc  hl
			ld   [hl], LOW(OBJLstPtrTable_Bird)	; iOBJInfo_OBJLstPtrTbl_Low
			inc  hl
			ld   [hl], HIGH(OBJLstPtrTable_Bird)	; iOBJInfo_OBJLstPtrTbl_High
			inc  hl
			ld   [hl], $00	; iOBJInfo_OBJLstPtrTblOffset


			; Set animation speed.
			ld   hl, iOBJInfo_FrameLeft
			add  hl, de
			ld   [hl], $06	; iOBJInfo_FrameLeft
			inc  hl
			ld   [hl], $06	; iOBJInfo_FrameTotal
			
			; Set initial position relative to the player's origin
	
			; =============== OBJLstS_Overlap ===============
			; Moves an wBJInfo to exactly overlap another one.
			; This copies the coordinates and OBJLstFlags from the source (BC) to destination (DE).
			;
			; Extracted to OBJLstS_Overlap in 96.
			;
			; IN
			; - DE: Ptr to the wOBJInfo structure to be moved
			; - BC: Ptr to target wOBJInfo structure (the "other" one)
			push bc
				;
				; Set up source and destination pointers
				;

				; BC = Ptr to source iOBJInfo_X
				ld   hl, iOBJInfo_X
				add  hl, bc			; HL = BC + iOBJInfo_X
				push hl
				pop  bc				; Move back to BC

				; DE = Ptr to destination iOBJInfo_X
				ld   hl, iOBJInfo_X
				add  hl, de			; HL = DE + iOBJInfo_X

				;
				; Copy the next 4 bytes over (iOBJInfo_X-iOBJInfo_YSub)
				;
		REPT 4
				ld   a, [bc]	; A = Source byte
				inc  bc			; SrcPtr++
				ldi  [hl], a	; Write to dest; DestPtr++
		ENDR
			pop  bc

			;
			; Copy over the byte with sprite mapping flags
			;

			; A = Source iOBJInfo_OBJLstFlags
			ld   hl, iOBJInfo_OBJLstFlags
			add  hl, bc
			ld   a, [hl]
			; HL = Ptr to dest iOBJInfo_OBJLstFlags
			ld   hl, iOBJInfo_OBJLstFlags
			add  hl, de
			; Write it over
			ld   [hl], a
			; ==============================
			
			;
			; During the intro/outro, the round text graphics take up the location
			; in VRAM that the bird uses.
			;
			; To get around that, the bird is spawned off-screen above, then descends once the
			; graphics load (and when the round ends, it flies back offscreen).
			;
			mMvC_SetMoveH -$3000
			mMvC_SetMoveV -$7000
	
			;
			; Initialize Mamahaha-specific fields
			;
			
			ld   hl, iOBJInfo_Bird_Mode
			add  hl, de
			
			; Set the initial mode (wait to descend)
			ld   [hl], PLAY_BIRD_MODE_INIT ; iOBJInfo_Bird_Mode
			inc  hl
			; Wait for 20 frames
			ld   [hl], $16 ; iOBJInfo_Bird_Timer
			inc  hl
			; [TCRF] Value never read from
			ld   [hl], $00 ; iOBJInfo_Bird_Unused_29
			
		pop  de
	pop  bc
	ret
	
; =============== ExOBJ_Bird ===============
; Animation code for Mamahaha.
; IN
; - DE: Ptr to the wOBJInfo slot
; - BC: Ptr to wPlInfo*+$200
ExOBJ_Bird:

	; Depending on the mode...
	ld   hl, iOBJInfo_Bird_Mode
	add  hl, de
	ld   a, [hl]
	cp   PLAY_BIRD_MODE_INIT
	jp   z, ExOBJ_Bird_Init
	cp   PLAY_BIRD_MODE_IDLE
	jp   z, ExOBJ_Bird_Idle
	cp   PLAY_BIRD_MODE_OUTRO
	jp   z, ExOBJ_Bird_Outro
	cp   PLAY_BIRD_MODE_FLIGHT
	jp   z, ExOBJ_Bird_Flight
	jp   ExOBJ_Bird_Anim ; We never get here
	
; --------------- mode #0 ---------------
; Initialization mode.
; Wait the previously set 20 frames before switching to #1.
ExOBJ_Bird_Init:

	; Wait for the timer to elapse
	ld   hl, iOBJInfo_Bird_Timer
	add  hl, de
	dec  [hl]					; iOBJInfo_Bird_Timer--
	jp   nz, ExOBJ_Bird_Anim	; Elapsed? If not, skip
	
	; Otherwise, continue to #1
	dec  hl ; Seek back to iOBJInfo_Bird_Mode
	ld   [hl], PLAY_BIRD_MODE_IDLE
	jp   ExOBJ_Bird_Anim
	
; --------------- mode #1 ---------------
; Main gameplay mode.
ExOBJ_Bird_Idle:

	;
	; If the round is over, switch to the outro mode (fly away).
	; Otherwise, sync relative to the player's position.
	;
	call ExOBJ_Bird_IsRoundOver		; Is the round over?
	jp   nc, .syncPos				; If not, jump
	
.startFlyAway:

	; Next mode
	ld   hl, iOBJInfo_Bird_Mode
	add  hl, de
	ld   [hl], PLAY_BIRD_MODE_OUTRO
	
	; Fly away for 32 frames.
	; This should be enough to move the bird fully off-screen before despawning it.
	inc  hl ; iOBJInfo_Bird_Timer
	ld   [hl], $20
	jp   ExOBJ_Bird_Anim
	
.syncPos:

	;
	; Adjust Mamahaha's speed to get closer to its target position.
	;
	; To avoid having the bird perfectly mimic Nakoruru's movement, the
	; bird's speed is set to 1/8th of the distance between the current
	; and target coordinates.
	;

	;
	; Set the Horizontal Speed
	; SpeedH = TargetDistance / 8
	;
	ld   a, +$08 ; Target: 8px behind Nakoruru
	call ExOBJ_Bird_GetPlDistanceX
	ld   h, a		; HL = Target >> 3
	ld   l, $00
REPT 3
	sra  h
	rr   l
ENDR
	call Play_OBJLstS_SetSpeedH
	
	;
	; Set the Vertical Speed
	; SpeedV = TargetDistance / 8
	;
	ld   a, -$30 ; Target: $30px above Nakoruru
	call ExOBJ_Bird_GetPlDistanceY
	ld   h, a		; HL = Target >> 3
	ld   l, $00
REPT 3
	sra  h
	rr   l
ENDR
	call Play_OBJLstS_SetSpeedV
	
	;
	; Apply the vertical and horizontal speed we just set
	;
	mMvC_DoGravityV $0000
	call OBJLstS_ApplyXSpeed
	jp   ExOBJ_Bird_Anim
	
; --------------- mode #2 ---------------
; Mamahaha flies up, offscreen.
ExOBJ_Bird_Outro:
	
	; Move up while waiting for the timer to elapse
	ld   hl, iOBJInfo_Bird_Timer
	add  hl, de
	dec  [hl]					; iOBJInfo_Bird_Timer--
	jp   nz, .moveUp			; Elapsed? If not, skip
	
	; Then despawn the bird
	call OBJLstS_Hide
	ret  
.moveUp:
	;
	; Apply upwards gravity to progressively move after, incrementing the
	; movement speed by around 0.12px every frame.
	;
	mMvC_DoGravityV -$0020
	jp   ExOBJ_Bird_Anim
	
; --------------- mode #3 ---------------
; Flight mode.
ExOBJ_Bird_Flight:

	; A = Player's Move ID
	; For explaination: ExOBJ_Bird_IsRoundOver
	push bc
		ld   hl, -(PLINFO_SIZE*2)
		add  hl, bc
		ld   bc, iPlInfo_MoveId
		add  hl, bc
		ld   a, [hl]
	pop  bc
	
	; Check if Nakoruru is still in flight mode (current move is Mamahaha Flight).
	; If she is, syncronize the bird's position relative to the player.
	cp   MOVE_NAKORURU_MAMAHAHA_FLIGHT_L
	jp   z, .syncPos
	cp   MOVE_NAKORURU_MAMAHAHA_FLIGHT_H
	jp   z, .syncPos
	
	; If she's not, it means we've just hopped off the bird.
	; Return to the main/idle gameplay mode.
.toIdle:
	ld   hl, iOBJInfo_Bird_Mode
	add  hl, de
	ld   [hl], PLAY_BIRD_MODE_IDLE
	jp   ExOBJ_Bird_Anim
.syncPos:
	; Show Mamahaha $18px above the player, at the same X position
	call ExOBJ_Bird_CopyPosFromPl
	mMvC_SetMoveH +$0000
	mMvC_SetMoveV -$1800
; --------------- animation ---------------	
ExOBJ_Bird_Anim:
	call OBJLstS_DoAnimTiming_Loop_by_DE
	ret
	

; =============== ExOBJ_Bird_CopyPosFromPl ===============
; Copies the player position to Mamahaha.
; Further adjustments can be made by calling mMvC_SetMove* after this subroutine.
;
; IN
; - DE: Ptr to wOBJInfo_Pl*Bird
ExOBJ_Bird_CopyPosFromPl:
	push bc
		push de
		
			; HL = Ptr to the player's iOBJInfo_X
			push de
				ld   hl, -(OBJINFO_SIZE*4) ; The player is 4 object slots before it
				add  hl, de
				ld   de, iOBJInfo_X
				add  hl, de
			pop  de
			
			; DE = Ptr to the bird's iOBJInfo_X
			inc  de ; to iOBJInfo_OBJLstFlags
			inc  de ; to iOBJInfo_OBJLstFlagsView
			inc  de ; to iOBJInfo_X
			
			; Copy over the coordinates from the player to the bird.
			
			; iOBJInfo_X
			ldi  a, [hl]
			ld   [de], a
			inc  de
			
			; iOBJInfo_XSub
			ldi  a, [hl]
			ld   [de], a
			inc  de
			
			; iOBJInfo_Y
			ldi  a, [hl]
			ld   [de], a
			inc  de
			
			; iOBJInfo_YSub
			ldi  a, [hl]
			ld   [de], a
		pop  de
	pop  bc
	ret
	
; =============== ExOBJ_Bird_GetPlDistanceX ===============
; Gets the distance between Mamahaha's current X position and the target one.
; This value is used to calculate the bird's speed, since it does not perfectly
; sync the player's movements, but rather it lags a bit behind.
;
; IN
; - A: Target X position, relative to the player.
;      This is relative to the player facing left (2P side).
; - DE: Ptr to wOBJInfo_Pl*Bird
; OUT
; - A: Distance value.
;      In practice: A = PlX + (PlXFlip ? -A : +A) - BirdX
ExOBJ_Bird_GetPlDistanceX:
	push bc
		push de
			
			; B = Mamahaha's current X Position (absolute)
			ld   hl, iOBJInfo_X
			add  hl, de
			ld   b, [hl]
			
			; HL = Ptr to Player OBJInfo (iOBJInfo_Status)
			ld   hl, -(OBJINFO_SIZE*4)
			add  hl, de
			
			;
			; C = Mamahaha's target X Position (relative to the player)
			;
			; The X target is relative to the player facing left, so if
			; they are facing right instead, invert the value.
			;
			inc  hl					; Seek to player's iOBJInfo_OBJLstFlags
			bit  SPRB_XFLIP, [hl]	; Is the player facing left? (2P side, flag not set)
			jp   z, .setTarget		; If so, skip
			cpl  					; Otherwise, A = -A
			inc  a
		.setTarget:
			ld   c, a				; And store it to C
			
			;
			; Copy the player's OBJInfo flags to the bird.
			; This makes sure the bird flips immediately when the player switches sides.
			;
			push de
				ld   a, [hl]		; A = Player iOBJInfo_OBJLstFlags
				inc  de				; Seek to bird's iOBJInfo_OBJLstFlags
				ld   [de], a		; Copy it there
			pop  de
			
			;
			; Finally, get the distance between the current and target Mamahaha positions.
			; A = PlayerX + Target - BirdCurX 
			;
			inc  hl					; Seek to Player iOBJInfo_OBJLstFlagsView
			inc  hl					; Seek to Player iOBJInfo_X
			ld   a, [hl]			; A = Player's X Position
			add  a, c				; A+=C to get the absolute target bird position
			sub  a, b				; A-=B to subtract the current bird position, and get the distance.
		pop  de
	pop  bc
	ret
	
; =============== ExOBJ_Bird_GetPlDistanceY ===============
; Gets the distance between Mamahaha's current Y position and the target one.
;
; Like ExOBJ_Bird_GetPlDistanceX except for the other coordinate.
; There is no Y flipping here, so it's handled in a simpler way.
;
; IN
; - A: Target Y position, relative to the player.
; - DE: Ptr to wOBJInfo_Pl*Bird
; OUT
; - A: Distance value.
;      In practice: A = PlY + A - BirdY
ExOBJ_Bird_GetPlDistanceY:
	push bc
		; B = Mamahaha's current Y Position (absolute)
		ld   hl, iOBJInfo_Y
		add  hl, de
		ld   b, [hl]
		
		; HL = Ptr to Player's Y Position (absolute)
		push de
			ld   hl, -(OBJINFO_SIZE*4)
			add  hl, de
			ld   de, iOBJInfo_Y
			add  hl, de
		pop  de
		
		; C = Mamahaha's target Y Position (relative to the player)
		ld   c, a
		
		; Get the distance between the current and target Mamahaha positions.
		; A = PlayerY + Target - BirdCurY
		ld   a, [hl]	; A = Pl iOBJInfo_Y
		add  a, c		; += Target
		sub  a, b		; -= BirdCurY
	pop  bc
	ret  
	
; =============== ExOBJ_Bird_IsRoundOver ===============
; Checks if the round is considered over.
;
; A round is considered over if time's up or a player is KO'd.
; This is used to check if the bird can fly away when the round ends.
;
; IN
; - BC: Ptr to wPlInfo*+$200
; OUT
; - C flag: If set, the round is over.
ExOBJ_Bird_IsRoundOver:

	;
	; Do not mess with the super move!
	;
	; Normally, the bird flies away immediately once the round is over, even mid-move.
	; This is a problem for the Super Move, because its last part involves a Bird Throw.
	;
	; Therefore, never return if doing the super.
	;
	
	; Seek to the player's Move ID.
	; Because of how Play_ExecExOBJCode handles incrementing the wPlInfo pointer,
	; this currently points to an invalid slot exactly two slots after the intended one.
	push bc
		; So, first, seek back two slots to get the real wPlInfo* pointer
		ld   hl, -(PLINFO_SIZE*2)
		add  hl, bc
		; Then to the move ID
		ld   bc, iPlInfo_MoveId
		add  hl, bc
	pop  bc
	
	ld   a, [hl]									; A = Move ID
	cp   MOVE_NAKORURU_ELERUSH_KAMUI_RIMSE_S		; Doing the super move?
	jp   z, ExOBJ_Bird_IsRoundOverNoSuper.retClear	; If so, it's not over
	
; =============== ExOBJ_Bird_IsRoundOverNoSuper ===============
; Performs the raw "Round Over" check, without considering the super move.
; OUT
; - C flag: If set, the round is over.
ExOBJ_Bird_IsRoundOverNoSuper:

	; If Time's Up, the round is over
	ld   a, [wRoundTime]
	or   a
	jp   z, .retSet
	
	; If either of the two players is KO'd, the round is over
	ld   a, [wPlInfo_Pl1+iPlInfo_Health]
	or   a
	jp   z, .retSet
	ld   a, [wPlInfo_Pl2+iPlInfo_Health]
	or   a
	jp   z, .retSet
	
; Round not over
.retClear:
	scf  
	ccf  	; C flag clear
	ret
; Round over
.retSet:
	scf    	; C flag set
	ret
	
; =============== END OF BANK ===============
; Unknown large chunk in the Japanese version, Junk area below.
	mIncJunk "L167DD3"